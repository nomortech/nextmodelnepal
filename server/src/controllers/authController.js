import bcrypt from "bcrypt";
import { FROM_EMAIL, SECRET_KEY } from "../config/config.js";
import { HttpStatus } from "../constant/constants.js";
import { ExpiredTokenStore, User } from "../schemaModels/model.js";
import { generateAuthToken, sendMail } from "../utils/index.js";
import { randomInt } from "crypto";

import {
    asyncErrorHandler,
    throwError,
    sendSuccessResponse,
} from "../helpers/index.js";

export const login = asyncErrorHandler(async (req, res) => {
    const { email, password } = req.body;

    if (!email || !password) {
        throwError({
            message: "Email and password required",
            statusCode: HttpStatus.BAD_REQUEST,
        });
    }

    const user = await User.findOne({ email });

    if (!user) {
        throwError({
            message: "User does not exist with this email address",
            statusCode: HttpStatus.NOT_FOUND,
        });
    }

    // Comparing the password
    const isPasswordValid = await bcrypt.compare(password, user.password);

    if (!isPasswordValid) {
        throwError({
            message: "Wrong password, please check your password",
            statusCode: HttpStatus.UNAUTHORIZED,
        });
    }

    const { fullName, phoneNumber, role, userImg } = user;

    // Cannot send password to frontend because of security issues
    const userInfoForToken = { fullName, phoneNumber, role, userImg, email };

    const authToken = generateAuthToken(userInfoForToken);

    if (!user.isAutoGeneratedPasswordChanged) {
        sendSuccessResponse({
            res,
            statusCode: HttpStatus.OK,
            message: `Authentication successful. Please change your auto generated password for security reasons`,
            data: {
                fullName,
                phoneNumber,
                role,
                userImg,
                email,
                isAutoGeneratedPasswordChanged:
                    user.isAutoGeneratedPasswordChanged,
                authToken,
            },
        });
        return;
    }

    //   Cookie expiry date will be one month from date of cookie set
    const cookieExpiryDate = new Date();
    cookieExpiryDate.setDate(cookieExpiryDate.getDate() + 30);

    //   Setting cookie to response
    res.cookie("authToken", authToken, { expires: cookieExpiryDate });

    sendSuccessResponse({
        res,
        statusCode: HttpStatus.OK,
        message: `Authentication successful, Welcome ${user.fullName}`,
        data: {
            fullName,
            phoneNumber,
            role,
            userImg,
            email,
        },
    });
});

export const logout = asyncErrorHandler(async (req, res) => {
    const authToken = req.cookies.authToken || "";

    if (authToken) {
        const tokeStore = new ExpiredTokenStore({ token: authToken });
        await tokeStore.save();
    }

    res.clearCookie("authToken");

    sendSuccessResponse({
        res,
        statusCode: HttpStatus.OK,
        message: "Logout successfully",
    });
});

export const changePassword = asyncErrorHandler(async (req, res) => {
    const { email, oldPassword, newPassword } = req.body;

    if (!email || !oldPassword || !newPassword) {
        throwError({
            message: "Email, Old password and new password are required",
            statusCode: HttpStatus.BAD_REQUEST,
        });
    }

    const user = await User.findOne({ email });

    if (!user) {
        throwError({
            message: "User does not exist with this email address",
            statusCode: HttpStatus.NOT_FOUND,
        });
    }

    // Comparing the password
    const isOldPasswordValid = await bcrypt.compare(oldPassword, user.password);

    if (!isOldPasswordValid) {
        throwError({
            message: "Wrong password, please check your password",
            statusCode: HttpStatus.UNAUTHORIZED,
        });
    }

    user.password = newPassword;

    await user.save();

    sendSuccessResponse({
        res,
        statusCode: HttpStatus.OK,
        message: "Password has been changed successfully",
    });
});

export const resetPassword = asyncErrorHandler(async (req, res) => {
    const newPassword = req.body.password;
    const authToken = req.authToken;
    const userInfo = req.user;

    if (!newPassword) {
        throwError({
            message: "New Password is required",
            statusCode: HttpStatus.BAD_REQUEST,
        });
    }

    if (!userInfo || !authToken) {
        throwError({
            message: "User info and auth token is required",
            statusCode: HttpStatus.BAD_REQUEST,
        });
    }

    const user = await User.findOne({ email: userInfo.email });

    if (!user) {
        throwError({
            message: "User does not exist with this email address",
            statusCode: HttpStatus.NOT_FOUND,
        });
    }

    user.password = newPassword;
    user.isAutoGeneratedPasswordChanged = true;

    const tokenStore = new ExpiredTokenStore({
        token: authToken,
    });

    //   Saving user and tokenStore to database at the same time
    Promise.allSettled([user.save(), tokenStore.save()]);

    sendSuccessResponse({
        res,
        message: "Password is changed successfully",
        statusCode: HttpStatus.OK,
    });
});

export const generateOTP = asyncErrorHandler(async (req, res) => {
    const email = req.body.email;

    if (!email) {
        throwError({
            message: "Email is required",
            statusCode: HttpStatus.BAD_REQUEST,
        });
    }

    const user = await User.findOne({ email });

    if (!user) {
        throwError({
            message: "User does not exist with this email address",
            statusCode: HttpStatus.NOT_FOUND,
        });
    }

    //   Generating OTP
    user.verificationCode.code = randomInt(100000, 999999);

    // Sending mail to the user
    const mailMessage = {
        from: FROM_EMAIL,
        // Email or array of email
        to: user.email,
        subject: "OTP for password reset",
        // Mail Message should be here in html format
        html: `
            <h3>Your One-Time Password (OTP) Code</h3>
            <p>Dear ${user.fullName},</p>
            <p>Your OTP code for Password change is:<strong>${user.verificationCode.code}</strong></p>
            <p>This OTP code is valid for a 5 minutes only. Please use it within the specified time frame.</p>
            <p>Regards,</p>
            <p>Doctor Appointment System </p>
        `,
    };

    Promise.allSettled([user.save(), sendMail(mailMessage)]);

    sendSuccessResponse({
        res,
        message: "Your OPT code has been sent to mail. Please check it",
        statusCode: HttpStatus.OK,
        data: {
            verificationCode: user.verificationCode.code,
        },
    });
});

export const forgotPassword = asyncErrorHandler(async (req, res) => {
    const { email, verificationCode, newPassword } = req.body;

    if (!email || !verificationCode || !newPassword) {
        throwError({
            message: "Email, verification code and password is required",
            statusCode: HttpStatus.BAD_REQUEST,
        });
    }

    const user = await User.findOne({ email });

    if (!user) {
        throwError({
            message: "User does not exist with this email address",
            statusCode: HttpStatus.BAD_REQUEST,
        });
    }

    const verificationCodeExpiration = new Date(
        user.verificationCode.expiration
    );

    const isOPTCodeValid =
        user.verificationCode.code == verificationCode &&
        verificationCodeExpiration > new Date();

    if (!isOPTCodeValid) {
        throwError({
            message: "Incorrect OTP code, please check and enter correct OTP",
            statusCode: HttpStatus.BAD_REQUEST,
        });
    }

    user.password = newPassword;
    user.verificationCode.code = null;
    user.verificationCode.expiration = null;

    await user.save();

    sendSuccessResponse({
        res,
        message: "Your password has been changed successfully",
        statusCode: HttpStatus.OK,
    });
});
